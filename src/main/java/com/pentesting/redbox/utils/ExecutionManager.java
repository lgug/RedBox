package com.pentesting.redbox.utils;

import com.pentesting.redbox.advisors.Advisor;
import com.pentesting.redbox.beans.StreamGroup;
import com.pentesting.redbox.makers.Maker;
import com.pentesting.redbox.persistence.entities.Command;
import com.pentesting.redbox.persistence.entities.OutputCommand;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;
import java.lang.reflect.Field;
import java.util.*;

import static com.pentesting.redbox.beans.enums.OutputStatus.ERROR;
import static com.pentesting.redbox.beans.enums.OutputStatus.INTERRUPTED;
import static com.pentesting.redbox.beans.enums.OutputStatus.SUCCESS;

public class ExecutionManager {

    private static final Logger log = LoggerFactory.getLogger(ExecutionManager.class);

    public static String getEnvironmentVariable(String name) {
        Map<String, String> env = System.getenv();
        return env.get(name);
    }

    public static void setEnvironmentVariable(String name, String value) throws IllegalAccessException, NoSuchFieldException {
        Class[] classes = Collections.class.getDeclaredClasses();
        Map<String, String> env = System.getenv();
        for(Class cl : classes) {
            if ("java.util.Collections$UnmodifiableMap".equals(cl.getName())) {
                Field field = cl.getDeclaredField("m");
                field.setAccessible(true);
                Object obj = field.get(env);
                Map<String, String> map = (Map<String, String>) obj;
                map.put(name, value);
            }
        }
    }

    private synchronized static StreamGroup execute(Command command) throws IOException, InterruptedException {
        List<String> output = new ArrayList<>();
        List<String> error = new ArrayList<>();

        Process process;
        String[] arrayCommand = command.toArray();

        ProcessBuilder pb = new ProcessBuilder(arrayCommand);
        Map<String, String> env = pb.environment();
        env.put("LANG", "en_US.UTF-8");
        env.put("LANGUAGE", "en");

        process = pb.start();
        log.info("EXECUTION > " + "STARTING COMMAND: " + command.getFullCommand());

        BufferedReader successBuffer = new BufferedReader(
                new InputStreamReader(process.getInputStream())
        );
        String s1;
        while ((s1 = successBuffer.readLine()) != null) {
            log.info("EXECUTION > " + s1);
            output.add(s1);
        }

        BufferedReader errorBuffer = new BufferedReader(
                new InputStreamReader(process.getErrorStream())
        );
        String s2;
        while ((s2 = errorBuffer.readLine()) != null) {
            log.error("EXECUTION > " + "ERROR: " + s2);
            error.add(s2);
        }

        process.waitFor();
        process.destroy();
        log.info("EXECUTION > " + "FINISHED");

        return new StreamGroup(output, new ArrayList<>(), error);
    }


    public static OutputCommand execute(Command command, Maker maker, Advisor advisor) {
        Command rightCommand = maker.makeTheRightCommand(command);
        StreamGroup streamGroup;
        try {
            streamGroup = execute(rightCommand);
        } catch (IOException | InterruptedException e) {
            return new OutputCommand(command, INTERRUPTED, Collections.singletonList(e.getMessage()));
        }

        StreamGroup rightStreamGroup = advisor.processLists(streamGroup.getSuccessfulList(), streamGroup.getErrorList());
        if (rightStreamGroup.getErrorList().size() > 0) {
            return new OutputCommand(command, ERROR, rightStreamGroup.getErrorList());
        } else {
            return new OutputCommand(command, SUCCESS, rightStreamGroup.getSuccessfulList());
        }
    }

}
