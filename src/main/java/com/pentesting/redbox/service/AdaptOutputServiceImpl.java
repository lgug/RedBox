package com.pentesting.redbox.service;

import com.pentesting.redbox.adapters.*;
import com.pentesting.redbox.adapters.utils.*;
import com.pentesting.redbox.utils.ExploitRank;
import com.pentesting.redbox.utils.PortStatus;
import com.pentesting.redbox.utils.PortTransportProtocol;
import com.pentesting.redbox.utils.exceptions.CannotAdaptCommandOutputException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.sql.Date;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@SuppressWarnings("ResultOfMethodCallIgnored")
@Service
public class AdaptOutputServiceImpl implements AdaptOutputService {

    private static final Logger log = LoggerFactory.getLogger(AdaptOutputServiceImpl.class);

    // insert support for net scan
    @Override
    public Fping_OutputAdapter adaptToFping(List<String> outputLines) throws CannotAdaptCommandOutputException {
        Fping_OutputAdapter fping_outputAdapter = new Fping_OutputAdapter();
        Pattern pattern = Pattern.compile("(.*)(( is ((alive)|(unreachable)))|(: Name or service not known))");
        Matcher matcher;
        for (String line: outputLines) {
            matcher = pattern.matcher(line);
            while (true) {
                try {
                    fping_outputAdapter.setHost(matcher.group(1));
                    String group5 = matcher.group(5);
                    String group6 = matcher.group(6);
                    String group7 = matcher.group(7);
                    if (group5 != null) {
                        fping_outputAdapter.setAlive(true);
                        fping_outputAdapter.setExists(true);
                    } else if (group6 != null) {
                        fping_outputAdapter.setAlive(false);
                        fping_outputAdapter.setExists(true);
                    } else if (group7 != null) {
                        fping_outputAdapter.setAlive(false);
                        fping_outputAdapter.setExists(false);
                    }
                    break;
                } catch (IllegalStateException e) {
                    if (!matcher.matches()) throw new CannotAdaptCommandOutputException(e.getMessage(), null);
                }

            }
        }
        return fping_outputAdapter;
    }

    @Override
    public Ifconfig_OutputAdapter adaptToIfconfig(List<String> outputLines) throws CannotAdaptCommandOutputException {
        Ifconfig_OutputAdapter ifconfig_outputAdapter = new Ifconfig_OutputAdapter();
        ifconfig_outputAdapter.setInterfaceList(new ArrayList<>());

        Pattern startInterfacePattern = Pattern.compile("(\\w*)\\s+Link encap:((Ethernet\\s+HWaddr?\\s+([\\dabcdef:]+))|(Local\\s+Loopback))\\s*");
        Pattern netAddressesPattern = Pattern.compile("\\s+inet addr:([\\d.]{7,15})?\\s+(Bcast:([\\d.]{7,15}))?\\s+Mask:([\\d.]{7,15})\\s?");
        Pattern ipv6AddressPattern = Pattern.compile("\\s+inet6 addr:\\s?([\\dabcdef:/]+)\\s+Scope:\\s?([\\w]+)");

        Matcher matcher;
        NetInterface netInterface = null;
        boolean interfacePending = false;
        for (String line: outputLines) {
            if (startInterfacePattern.matcher(line).matches() && !interfacePending)  {
                netInterface = new NetInterface();
                interfacePending = true;
            }
            if (startInterfacePattern.matcher(line).matches() && interfacePending) {
                matcher = startInterfacePattern.matcher(line);
                log.info(String.valueOf(matcher.groupCount()));
                matcher.matches();
                netInterface.setName(matcher.group(1));
                netInterface.setMacAddress(matcher.group(4));
            } else if (netAddressesPattern.matcher(line).matches() && interfacePending) {
                matcher = netAddressesPattern.matcher(line);
                log.info(String.valueOf(matcher.groupCount()));
                matcher.matches();
                netInterface.setIpv4Address(matcher.group(1));
                netInterface.setBroadcastAddress(matcher.group(3));
                netInterface.setSubnetMask(matcher.group(4));
            } else if (ipv6AddressPattern.matcher(line).matches() && interfacePending) {
                matcher = ipv6AddressPattern.matcher(line);
                log.info(String.valueOf(matcher.groupCount()));
                matcher.matches();
                netInterface.setIpv6Address(matcher.group(1));
                interfacePending = false;
                ifconfig_outputAdapter.insertIntoInterfaceList(netInterface);
            }
        }
        return ifconfig_outputAdapter;
    }

//    @Override
//    public Macchanger_OutputAdapter adaptToMacchanger(List<String> outputLines) throws CannotAdaptCommandOutputException {
//        Macchanger_OutputAdapter macchanger_outputAdapter = new Macchanger_OutputAdapter();
//
//        String currentMacPattern = "Current MAC:[\\s]+.{17}[\\s]+\\(.*\\)";
//        String permanentMacPattern = "Permanent MAC:[\\s]+.{17}[\\s]+\\(.*\\)";
//        String newMacPattern = "New MAC:[\\s]+.{17}[\\s]+\\(.*\\)";
//
//        for (String line: outputLines) {
//            if (line.matches(currentMacPattern)) {
//                macchanger_outputAdapter.setCurrentMac(StringGetter.getMACAddress(line));
//            } else if (line.matches(permanentMacPattern)){
//                macchanger_outputAdapter.setPermanentMac(StringGetter.getMACAddress(line));
//            } else if (line.matches(newMacPattern)){
//                macchanger_outputAdapter.setNewMac(StringGetter.getMACAddress(line));
//            } else {
//                throw new CannotAdaptCommandOutputException();
//            }
//        }
//        return macchanger_outputAdapter;
//    }

    @Override
    public NMAP_OutputAdapter adaptToNMAP(List<String> outputLines) throws CannotAdaptCommandOutputException {
        NMAP_OutputAdapter nmap_outputAdapter = new NMAP_OutputAdapter();
        nmap_outputAdapter.setHostScanList(new ArrayList<>());

        Pattern initPattern = Pattern.compile("Starting Nmap [\\d.]+ \\( https://nmap\\.org \\) at .*");
        Pattern hostStartScanPattern = Pattern.compile("Nmap scan report for (.*)");
        Pattern hostStatusPattern = Pattern.compile("(Note: )?Host ((seems down)|(is up)).*");
        Pattern portStatusRowPattern = Pattern.compile("(\\d+)/(tcp|udp)\\s+([\\w\\|]+)\\s+(.+)");
        Pattern endingPattern = Pattern.compile("Nmap done: (\\d)+ IP address(es)? \\([\\d]+ host[s]? up\\) scanned in ([\\d.]+) seconds");

        Matcher matcher;
        HostScan hostScan = null;
        for (String line: outputLines) {

            if(outputLines.indexOf(line) == 1 && !initPattern.matcher(line).matches())
                throw new CannotAdaptCommandOutputException(null);

            if (hostStartScanPattern.matcher(line).matches()) {
                matcher = hostStartScanPattern.matcher(line);
                matcher.matches();
                if (hostScan != null) nmap_outputAdapter.insertIntoHostScanList(hostScan);
                hostScan = new HostScan();
                hostScan.setPorts(new ArrayList<>());
                hostScan.setHostname(matcher.group(1));
            } else if (hostStatusPattern.matcher(line).matches()) {
                matcher = hostStatusPattern.matcher(line);
                matcher.matches();
                if (matcher.group(3) != null) Objects.requireNonNull(hostScan).setUp(false);
                else Objects.requireNonNull(hostScan).setUp(true);
            } else if (portStatusRowPattern.matcher(line).matches()) {
                matcher = portStatusRowPattern.matcher(line);
                matcher.matches();
                Port port = new Port();
                port.setPortNumber(Integer.parseInt(matcher.group(1)));
                port.setProtocol(PortTransportProtocol.valueOf(matcher.group(2).toUpperCase()));
                port.setPortStatus(PortStatus.valueOf(matcher.group(3).toUpperCase().replace("|", "_")));
                port.setService(matcher.group(4));
                Objects.requireNonNull(hostScan).insertIntoPorts(port);
            } else if (endingPattern.matcher(line).matches()) {
                matcher = endingPattern.matcher(line);
                matcher.matches();
                if (hostScan != null) nmap_outputAdapter.insertIntoHostScanList(hostScan);
                nmap_outputAdapter.setScanningTime(Float.valueOf(matcher.group(3)));
            }
        }
        return nmap_outputAdapter;
    }

    @Override
    public OpenVAS_OutputAdapter adaptToOpenVAS(List<String> outputLines) throws CannotAdaptCommandOutputException {
        OpenVAS_OutputAdapter openVAS_outputAdapter = new OpenVAS_OutputAdapter();

        Pattern firstLineReportPattern = Pattern.compile("I Summary");
        Pattern issueLineReportPattern = Pattern.compile("Issue");
        Pattern nvtLineReportPattern = Pattern.compile("NVT:\\s+(.*)");
        Pattern threatLineReportPattern = Pattern.compile("Threat:\\s+(.*)");
        Pattern portLineReportPattern = Pattern.compile("Port:\\s+(.*)");
        Pattern descriptionLineReportPattern = Pattern.compile("Summary:");

        Pattern reportTaskPattern = Pattern.compile("([\\dabcdef\\-]+)");
        Pattern taskResponsePattern = Pattern.compile("<create_task_response id=\"([\\dabcdef\\-]+)\" status_text=\"(.*)\" status=\"(\\d+)\"></create_task_response>");
        Pattern targetResponsePattern = Pattern.compile("<create_target_response id=\"([\\dabcdef\\-]+)\" status_text=\"(.*)\" status=\"(\\d+)\"></create_target_response>");

        boolean report = false;
        boolean inIssue = false;
        boolean summaryIssue = false;
        List<Vulnerability> vulnerabilityList = null;
        Vulnerability vulnerability = null;
        Matcher matcher;
        for (String line: outputLines) {
            if (report) {
                if (issueLineReportPattern.matcher(line).matches()) {
                    inIssue = true;
                    vulnerability = new Vulnerability();
                }
                if (inIssue) {
                    if (nvtLineReportPattern.matcher(line).matches()) {
                        matcher = nvtLineReportPattern.matcher(line);
                        matcher.matches();
                        vulnerability.setName(matcher.group(1));
                    } else if (threatLineReportPattern.matcher(line).matches()) {
                        matcher = threatLineReportPattern.matcher(line);
                        matcher.matches();
                        vulnerability.setThreatLevel(matcher.group(1));
                    } else if (portLineReportPattern.matcher(line).matches()) {
                        matcher = portLineReportPattern.matcher(line);
                        matcher.matches();
                        vulnerability.setPort(matcher.group(1));
                    } else if (descriptionLineReportPattern.matcher(line).matches()) {
                        summaryIssue = true;
                    } else if (summaryIssue) {
                        vulnerability.setDescription(line);
                        summaryIssue = false;
                        vulnerabilityList.add(vulnerability);
                        inIssue = false;
                    }
                }
            } else if (reportTaskPattern.matcher(line).matches()) {
                matcher = reportTaskPattern.matcher(line);
                matcher.matches();
                openVAS_outputAdapter.setReportId(matcher.group(1));
            } else if (taskResponsePattern.matcher(line).matches()) {
                matcher = taskResponsePattern.matcher(line);
                matcher.matches();
                if (matcher.group(3).matches("2[\\d]{2}")) {
                    openVAS_outputAdapter.setTaskId(matcher.group(1));
                }
            } else if (targetResponsePattern.matcher(line).matches()) {
                matcher = targetResponsePattern.matcher(line);
                matcher.matches();
                if (matcher.group(3).matches("2[\\d]{2}")) {
                    openVAS_outputAdapter.setTargetId(matcher.group(1));
                }
            } else if (firstLineReportPattern.matcher(line).matches()) {
                vulnerabilityList = new ArrayList<>();
                report = true;
            }
        }

        if (report) {
            openVAS_outputAdapter.setTaskResult(new TaskResult(vulnerabilityList));
            openVAS_outputAdapter.calculateThreatTypesNumber();
        }
        return openVAS_outputAdapter;
    }

    @Override
    public Metasploit_OutputAdapter adaptToMetasploit(List<String> outputLines) throws CannotAdaptCommandOutputException {
        Metasploit_OutputAdapter metasploit_outputAdapter = new Metasploit_OutputAdapter();
        metasploit_outputAdapter.setExploitList(new ArrayList<>());

        Pattern exploitRowPattern = Pattern.compile("\\s*(exploit/[\\w/]+)\\s+(\\d{4}-\\d{2}-\\d{2})?\\s+(\\w+)\\s+(.*)");

        for (String line: outputLines) {
            if (exploitRowPattern.matcher(line).matches()) {
                Exploit exploit = new Exploit();
                Matcher matcher = exploitRowPattern.matcher(line);
                matcher.matches();
                exploit.setName(matcher.group(1));
                if (matcher.group(2) != null) exploit.setDisclosureDate(Date.valueOf(matcher.group(2)));
                exploit.setRank(ExploitRank.valueOf(matcher.group(3).toUpperCase()));
                exploit.setDescription(matcher.group(4));

                metasploit_outputAdapter.addToExploitList(exploit);
            }
        }

        return metasploit_outputAdapter;
    }

    @Override
    public OutputAdapter adapt(List<String> outputLines, String command) throws CannotAdaptCommandOutputException {
        OutputAdapter outputAdapter;
        switch (command) {
            case "fping":
                outputAdapter = adaptToFping(outputLines);
                break;
            case "ifconfig":
                outputAdapter = adaptToIfconfig(outputLines);
                break;
            case "nmap":
                outputAdapter = adaptToNMAP(outputLines);
                break;
            case "omp":
                outputAdapter = adaptToOpenVAS(outputLines);
                break;
            case "msfconsole":
                outputAdapter = adaptToMetasploit(outputLines);
                break;
            default:
                outputAdapter = new Generic_OutputAdapter(outputLines);
        }
        return outputAdapter;
    }
}
