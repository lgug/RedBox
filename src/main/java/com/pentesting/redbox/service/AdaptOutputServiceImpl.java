package com.pentesting.redbox.service;

import com.pentesting.redbox.adapters.*;
import com.pentesting.redbox.adapters.utils.HostScan;
import com.pentesting.redbox.adapters.utils.NetInterface;
import com.pentesting.redbox.adapters.utils.Port;
import com.pentesting.redbox.utils.PortStatus;
import com.pentesting.redbox.utils.PortTransportProtocol;
import com.pentesting.redbox.utils.exceptions.CannotAdaptCommandOutputException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@SuppressWarnings("ResultOfMethodCallIgnored")
@Service
public class AdaptOutputServiceImpl implements AdaptOutputService {

    private static final Logger log = LoggerFactory.getLogger(AdaptOutputServiceImpl.class);

    // insert support for net scan
    @Override
    public Fping_OutputAdapter adaptToFping(List<String> outputLines) throws CannotAdaptCommandOutputException {
        Fping_OutputAdapter fping_outputAdapter = new Fping_OutputAdapter();
        Pattern pattern = Pattern.compile("(.*)(( is ((alive)|(unreachable)))|(: Name or service not known))");
        Matcher matcher;
        for (String line: outputLines) {
            matcher = pattern.matcher(line);
            while (true) {
                try {
                    fping_outputAdapter.setHost(matcher.group(1));
                    String group5 = matcher.group(5);
                    String group6 = matcher.group(6);
                    String group7 = matcher.group(7);
                    if (group5 != null) {
                        fping_outputAdapter.setAlive(true);
                        fping_outputAdapter.setExists(true);
                    } else if (group6 != null) {
                        fping_outputAdapter.setAlive(false);
                        fping_outputAdapter.setExists(true);
                    } else if (group7 != null) {
                        fping_outputAdapter.setAlive(false);
                        fping_outputAdapter.setExists(false);
                    }
                    break;
                } catch (IllegalStateException e) {
                    if (!matcher.matches()) throw new CannotAdaptCommandOutputException(e.getMessage(), null);
                }

            }
        }
        return fping_outputAdapter;
    }

    @Override
    public Ifconfig_OutputAdapter adaptToIfconfig(List<String> outputLines) throws CannotAdaptCommandOutputException {
        Ifconfig_OutputAdapter ifconfig_outputAdapter = new Ifconfig_OutputAdapter();
        ifconfig_outputAdapter.setInterfaceList(new ArrayList<>());

        Pattern startInterfacePattern = Pattern.compile("(\\w*)\\s+Link encap:((Ethernet\\s+HWaddr?\\s+([\\dabcdef:]+))|(Local\\s+Loopback))\\s*");
        Pattern netAddressesPattern = Pattern.compile("\\s+inet addr:([\\d.]{7,15})?\\s+(Bcast:([\\d.]{7,15}))?\\s+Mask:([\\d.]{7,15})\\s?");
        Pattern ipv6AddressPattern = Pattern.compile("\\s+inet6 addr:\\s?([\\dabcdef:/]+)\\s+Scope:\\s?([\\w]+)");

        Matcher matcher;
        NetInterface netInterface = null;
        boolean interfacePending = false;
        for (String line: outputLines) {
            if (startInterfacePattern.matcher(line).matches() && !interfacePending)  {
                netInterface = new NetInterface();
                interfacePending = true;
            }
            if (startInterfacePattern.matcher(line).matches() && interfacePending) {
                matcher = startInterfacePattern.matcher(line);
                log.info(String.valueOf(matcher.groupCount()));
                matcher.matches();
                netInterface.setName(matcher.group(1));
                netInterface.setMacAddress(matcher.group(4));
            } else if (netAddressesPattern.matcher(line).matches() && interfacePending) {
                matcher = netAddressesPattern.matcher(line);
                log.info(String.valueOf(matcher.groupCount()));
                matcher.matches();
                netInterface.setIpv4Address(matcher.group(1));
                netInterface.setBroadcastAddress(matcher.group(3));
                netInterface.setSubnetMask(matcher.group(4));
            } else if (ipv6AddressPattern.matcher(line).matches() && interfacePending) {
                matcher = ipv6AddressPattern.matcher(line);
                log.info(String.valueOf(matcher.groupCount()));
                matcher.matches();
                netInterface.setIpv6Address(matcher.group(1));
                interfacePending = false;
                ifconfig_outputAdapter.insertIntoInterfaceList(netInterface);
            }
        }
        return ifconfig_outputAdapter;
    }

//    @Override
//    public Macchanger_OutputAdapter adaptToMacchanger(List<String> outputLines) throws CannotAdaptCommandOutputException {
//        Macchanger_OutputAdapter macchanger_outputAdapter = new Macchanger_OutputAdapter();
//
//        String currentMacPattern = "Current MAC:[\\s]+.{17}[\\s]+\\(.*\\)";
//        String permanentMacPattern = "Permanent MAC:[\\s]+.{17}[\\s]+\\(.*\\)";
//        String newMacPattern = "New MAC:[\\s]+.{17}[\\s]+\\(.*\\)";
//
//        for (String line: outputLines) {
//            if (line.matches(currentMacPattern)) {
//                macchanger_outputAdapter.setCurrentMac(StringGetter.getMACAddress(line));
//            } else if (line.matches(permanentMacPattern)){
//                macchanger_outputAdapter.setPermanentMac(StringGetter.getMACAddress(line));
//            } else if (line.matches(newMacPattern)){
//                macchanger_outputAdapter.setNewMac(StringGetter.getMACAddress(line));
//            } else {
//                throw new CannotAdaptCommandOutputException();
//            }
//        }
//        return macchanger_outputAdapter;
//    }

    @Override
    public NMAP_OutputAdapter adaptToNMAP(List<String> outputLines) throws CannotAdaptCommandOutputException {
        NMAP_OutputAdapter nmap_outputAdapter = new NMAP_OutputAdapter();
        nmap_outputAdapter.setHostScanList(new ArrayList<>());

        Pattern initPattern = Pattern.compile("Starting Nmap [\\d.]+ \\( https://nmap\\.org \\) at .*");
        Pattern hostStartScanPattern = Pattern.compile("Nmap scan report for (.*)");
        Pattern hostStatusPattern = Pattern.compile("(Note: )?Host ((seems down)|(is up)).*");
        Pattern portStatusRowPattern = Pattern.compile("(\\d+)/(tcp|udp)\\s+(\\w+)\\s+(.+)");
        Pattern endingPattern = Pattern.compile("Nmap done: (\\d)+ IP address(es)? \\([\\d]+ host[s]? up\\) scanned in ([\\d.]+) seconds");

        Matcher matcher;
        HostScan hostScan = null;
        for (String line: outputLines) {

            if(outputLines.indexOf(line) == 1 && !initPattern.matcher(line).matches())
                throw new CannotAdaptCommandOutputException(null);

            if (hostStartScanPattern.matcher(line).matches()) {
                matcher = hostStartScanPattern.matcher(line);
                matcher.matches();
                if (hostScan != null) nmap_outputAdapter.insertIntoHostScanList(hostScan);
                hostScan = new HostScan();
                hostScan.setPorts(new ArrayList<>());
                hostScan.setHostname(matcher.group(1));
            } else if (hostStatusPattern.matcher(line).matches()) {
                matcher = hostStatusPattern.matcher(line);
                matcher.matches();
                if (matcher.group(3) != null) Objects.requireNonNull(hostScan).setUp(false);
                else Objects.requireNonNull(hostScan).setUp(true);
            } else if (portStatusRowPattern.matcher(line).matches()) {
                matcher = portStatusRowPattern.matcher(line);
                matcher.matches();
                Port port = new Port();
                port.setPortNumber(Integer.parseInt(matcher.group(1)));
                port.setProtocol(PortTransportProtocol.valueOf(matcher.group(2).toUpperCase()));
                port.setPortStatus(PortStatus.valueOf(matcher.group(3).toUpperCase()));
                port.setService(matcher.group(4));
                Objects.requireNonNull(hostScan).insertIntoPorts(port);
            } else if (endingPattern.matcher(line).matches()) {
                matcher = endingPattern.matcher(line);
                matcher.matches();
                if (hostScan != null) nmap_outputAdapter.insertIntoHostScanList(hostScan);
                nmap_outputAdapter.setScanningTime(Float.valueOf(matcher.group(3)));
            }
        }
        return nmap_outputAdapter;
    }

    @Override
    public OpenVAS_OutputAdapter adaptToOpenVAS(List<String> outputLines) throws CannotAdaptCommandOutputException {
        //work in progress
        return null;
    }

    @Override
    public Metasploit_OutputAdapter adaptToMetasploit(List<String> outputLines) throws CannotAdaptCommandOutputException {
        //work in progress
        return null;
    }

    @Override
    public OutputAdapter adapt(List<String> outputLines, String command) throws CannotAdaptCommandOutputException {
        OutputAdapter outputAdapter;
        switch (command) {
            case "fping":
                outputAdapter = adaptToFping(outputLines);
                break;
            case "ifconfig":
                outputAdapter = adaptToIfconfig(outputLines);
                break;
            case "nmap":
                outputAdapter = adaptToNMAP(outputLines);
                break;
            case "omp":
                outputAdapter = adaptToOpenVAS(outputLines);
                break;
            case "msfconsole":
                outputAdapter = adaptToMetasploit(outputLines);
                break;
            default:
                outputAdapter = new Generic_OutputAdapter(outputLines);
        }
        return outputAdapter;
    }
}
