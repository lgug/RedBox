package com.pentesting.redbox.service;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.pentesting.redbox.adapters.*;
import com.pentesting.redbox.beans.*;
import com.pentesting.redbox.beans.enums.*;
import com.pentesting.redbox.utils.Converter;
import com.pentesting.redbox.utils.ListsManager;
import com.pentesting.redbox.utils.exceptions.CannotAdaptCommandOutputException;
import com.pentesting.redbox.utils.exceptions.CommandExitWithErrorException;
import com.pentesting.redbox.utils.exceptions.SystemCommandException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StringReader;
import java.sql.Date;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@SuppressWarnings("ResultOfMethodCallIgnored")
@Service
public class AdaptOutputServiceImpl implements AdaptOutputService {

    private static final Logger log = LoggerFactory.getLogger(AdaptOutputServiceImpl.class);

    @Autowired
    SystemService systemService;

    @Override
    public SystemInfo_OutputAdapter adaptToLshw(List<String> outputLines) throws CannotAdaptCommandOutputException, IOException {
        SystemInfo_OutputAdapter systemInfo_outputAdapter = new SystemInfo_OutputAdapter();

        ObjectMapper objectMapper = new ObjectMapper();
        JsonNode rootNode = objectMapper.readTree(ListsManager.fromListToString(outputLines, '\n'));

        if (rootNode.path("class").textValue().equals("system")) {
            systemInfo_outputAdapter.setPcName(rootNode.path("id").textValue());
            systemInfo_outputAdapter.setSerialNumber(rootNode.path("serial").textValue());
        }

        JsonNode coreNode = rootNode.path("children");
        Iterator<JsonNode> coreNodeIterator = coreNode.elements();
        while (coreNodeIterator.hasNext()) {
            JsonNode childCoreNode = coreNodeIterator.next();
            String id = childCoreNode.path("id").textValue();
            switch (id) {
                case "cpu":
                    systemInfo_outputAdapter.setProcessor(childCoreNode.path("product").textValue());
                    systemInfo_outputAdapter.setArchitecture(childCoreNode.path("capabilities").path("x86-64").textValue());
                    break;
                case "memory":
                    systemInfo_outputAdapter.setRam(String.valueOf(
                            Converter.fromBytesTo(childCoreNode.path("size").intValue(), "G")) + "GB");
                    break;
            }
            String clazz = childCoreNode.path("class").textValue();
            switch (clazz) {
                case "storage":
                    Iterator<JsonNode> storageNodeIterator = childCoreNode.elements();
                    while (storageNodeIterator.hasNext()) {
                        JsonNode storageNode = storageNodeIterator.next();
                        if (storageNode.path("id").textValue().equals("disk") && storageNode.path("physid").textValue().equals("1")) {
                            systemInfo_outputAdapter.setStorage(String.valueOf(
                                    Converter.fromBytesTo(storageNode.path("size").intValue(), "G")) + "GB");
                            break;
                        }
                    }
                    break;
                case "bridge":
                    Iterator<JsonNode> bridgeNodeIterator = childCoreNode.elements();
                    while (bridgeNodeIterator.hasNext()) {
                        JsonNode bridgeNode = bridgeNodeIterator.next();
                        if (bridgeNode.path("id").textValue().equals("display")) {
                            systemInfo_outputAdapter.setGraphicCard(bridgeNode.path("product").textValue());
                            break;
                        }
                    }
                    break;
            }
        }

        try {
            systemInfo_outputAdapter.setOs(systemService.getOperativeSystem());
            systemInfo_outputAdapter.setUser(systemService.getCurrentUser());
        } catch (SystemCommandException | CommandExitWithErrorException ignored) { }

        return systemInfo_outputAdapter;
    }

    // insert support for net scan
    @Override
    public Fping_OutputAdapter adaptToFping(List<String> outputLines) throws CannotAdaptCommandOutputException {
        Fping_OutputAdapter fping_outputAdapter = new Fping_OutputAdapter();
        Pattern pattern = Pattern.compile("(.*)(( is ((alive)|(unreachable)))|(: Name or service not known))");
        Matcher matcher;
        for (String line: outputLines) {
            matcher = pattern.matcher(line);
            while (true) {
                try {
                    fping_outputAdapter.setHost(matcher.group(1));
                    String group5 = matcher.group(5);
                    String group6 = matcher.group(6);
                    String group7 = matcher.group(7);
                    if (group5 != null) {
                        fping_outputAdapter.setAlive(true);
                        fping_outputAdapter.setExists(true);
                    } else if (group6 != null) {
                        fping_outputAdapter.setAlive(false);
                        fping_outputAdapter.setExists(true);
                    } else if (group7 != null) {
                        fping_outputAdapter.setAlive(false);
                        fping_outputAdapter.setExists(false);
                    }
                    break;
                } catch (IllegalStateException e) {
                    if (!matcher.matches()) throw new CannotAdaptCommandOutputException(e.getMessage(), null);
                }

            }
        }
        return fping_outputAdapter;
    }

    @Override
    public Ifconfig_OutputAdapter adaptToIfconfig(List<String> outputLines) throws CannotAdaptCommandOutputException {
        Ifconfig_OutputAdapter ifconfig_outputAdapter = new Ifconfig_OutputAdapter();
        ifconfig_outputAdapter.setInterfaceList(new ArrayList<>());

        Pattern startInterfacePattern = Pattern.compile("(\\w*)\\s+Link encap:((Ethernet\\s+HWaddr?\\s+([\\dabcdef:]+))|(Local\\s+Loopback))\\s*");
        Pattern netAddressesPattern = Pattern.compile("\\s+inet addr:([\\d.]{7,15})?\\s+(Bcast:([\\d.]{7,15}))?\\s+Mask:([\\d.]{7,15})\\s?");
        Pattern ipv6AddressPattern = Pattern.compile("\\s+inet6 addr:\\s?([\\dabcdef:/]+)\\s+Scope:\\s?([\\w]+)");

        Matcher matcher;
        NetInterface netInterface = null;
        boolean interfacePending = false;
        for (String line: outputLines) {
            if (startInterfacePattern.matcher(line).matches() && !interfacePending)  {
                netInterface = new NetInterface();
                interfacePending = true;
            }
            if (startInterfacePattern.matcher(line).matches() && interfacePending) {
                matcher = startInterfacePattern.matcher(line);
                log.info(String.valueOf(matcher.groupCount()));
                matcher.matches();
                netInterface.setName(matcher.group(1));
                netInterface.setMacAddress(matcher.group(4));
            } else if (netAddressesPattern.matcher(line).matches() && interfacePending) {
                matcher = netAddressesPattern.matcher(line);
                log.info(String.valueOf(matcher.groupCount()));
                matcher.matches();
                netInterface.setIpv4Address(matcher.group(1));
                netInterface.setBroadcastAddress(matcher.group(3));
                netInterface.setSubnetMask(matcher.group(4));
            } else if (ipv6AddressPattern.matcher(line).matches() && interfacePending) {
                matcher = ipv6AddressPattern.matcher(line);
                log.info(String.valueOf(matcher.groupCount()));
                matcher.matches();
                netInterface.setIpv6Address(matcher.group(1));
                interfacePending = false;
                ifconfig_outputAdapter.insertIntoInterfaceList(netInterface);
            }
        }
        return ifconfig_outputAdapter;
    }

//    @Override
//    public Macchanger_OutputAdapter adaptToMacchanger(List<String> outputLines) throws CannotAdaptCommandOutputException {
//        Macchanger_OutputAdapter macchanger_outputAdapter = new Macchanger_OutputAdapter();
//
//        String currentMacPattern = "Current MAC:[\\s]+.{17}[\\s]+\\(.*\\)";
//        String permanentMacPattern = "Permanent MAC:[\\s]+.{17}[\\s]+\\(.*\\)";
//        String newMacPattern = "New MAC:[\\s]+.{17}[\\s]+\\(.*\\)";
//
//        for (String line: outputLines) {
//            if (line.matches(currentMacPattern)) {
//                macchanger_outputAdapter.setCurrentMac(StringGetter.getMACAddress(line));
//            } else if (line.matches(permanentMacPattern)){
//                macchanger_outputAdapter.setPermanentMac(StringGetter.getMACAddress(line));
//            } else if (line.matches(newMacPattern)){
//                macchanger_outputAdapter.setNewMac(StringGetter.getMACAddress(line));
//            } else {
//                throw new CannotAdaptCommandOutputException();
//            }
//        }
//        return macchanger_outputAdapter;
//    }

    @Override
    public NMAP_OutputAdapter adaptToNMAP(List<String> outputLines) throws CannotAdaptCommandOutputException {
        NMAP_OutputAdapter nmap_outputAdapter = new NMAP_OutputAdapter();
        nmap_outputAdapter.setHostScanList(new ArrayList<>());

        Pattern initPattern = Pattern.compile("Starting Nmap [\\d.]+ \\( https://nmap\\.org \\) at .*");
        Pattern hostStartScanPattern = Pattern.compile("Nmap scan report for (.*)");
        Pattern hostStatusPattern = Pattern.compile("(Note: )?Host ((seems down)|(is up)).*");
        Pattern portStatusRowPattern = Pattern.compile("(\\d+)/(tcp|udp)\\s+([\\w\\|]+)\\s+(.+)");
        Pattern endingPattern = Pattern.compile("Nmap done: (\\d)+ IP address(es)? \\([\\d]+ host[s]? up\\) scanned in ([\\d.]+) seconds");

        Matcher matcher;
        HostScan hostScan = null;
        for (String line: outputLines) {

            if(outputLines.indexOf(line) == 1 && !initPattern.matcher(line).matches())
                throw new CannotAdaptCommandOutputException(null);

            if (hostStartScanPattern.matcher(line).matches()) {
                matcher = hostStartScanPattern.matcher(line);
                matcher.matches();
                if (hostScan != null) nmap_outputAdapter.insertIntoHostScanList(hostScan);
                hostScan = new HostScan();
                hostScan.setPorts(new ArrayList<>());
                hostScan.setHostname(matcher.group(1));
            } else if (hostStatusPattern.matcher(line).matches()) {
                matcher = hostStatusPattern.matcher(line);
                matcher.matches();
                if (matcher.group(3) != null) Objects.requireNonNull(hostScan).setUp(false);
                else Objects.requireNonNull(hostScan).setUp(true);
            } else if (portStatusRowPattern.matcher(line).matches()) {
                matcher = portStatusRowPattern.matcher(line);
                matcher.matches();
                Port port = new Port();
                port.setPortNumber(Integer.parseInt(matcher.group(1)));
                port.setProtocol(PortTransportProtocol.valueOf(matcher.group(2).toUpperCase()));
                port.setPortStatus(PortStatus.valueOf(matcher.group(3).toUpperCase().replace("|", "_")));
                port.setService(matcher.group(4));
                Objects.requireNonNull(hostScan).insertIntoPorts(port);
            } else if (endingPattern.matcher(line).matches()) {
                matcher = endingPattern.matcher(line);
                matcher.matches();
                if (hostScan != null) nmap_outputAdapter.insertIntoHostScanList(hostScan);
                nmap_outputAdapter.setScanningTime(Float.valueOf(matcher.group(3)));
            }
        }
        return nmap_outputAdapter;
    }

    @Override
    public OpenVAS_OutputAdapter adaptToOpenVAS(List<String> outputLines) {
        String xml;
        if (outputLines.size() != 1) xml = ListsManager.fromListToString(outputLines, '\n');
        else xml = outputLines.get(0);

        //xml = "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>" + xml;

        try {
            DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newDefaultInstance();
            DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
            Document document = documentBuilder.parse(new InputSource(new StringReader(xml)));
            String rootElement = document.getDocumentElement().getNodeName();
            switch (rootElement) {
                case "create_target_response":
                    return adaptToTargetResponseOpenVAS(document);
                case "create_task_response":
                    return adaptToTaskResponseOpenVAS(document);
                case "get_tasks_response":
                    return adaptToTaskResponseOpenVAS(document);
                case "get_reports_response":
                    return adaptToReportResponseOpenVAS(document);
                case "start_task_response":
                    return adaptToReportResponseOpenVAS(document);
                default:
                    return null;
            }
        } catch (ParserConfigurationException | SAXException | IOException e) {
            e.printStackTrace();
            return null;
        }
    }

    @Override
    public TargetResponse_OpenVAS_OutputAdapter adaptToTargetResponseOpenVAS(Document xmlResource) {
        TargetResponse_OpenVAS_OutputAdapter tr_openVAS_outputAdapter = new TargetResponse_OpenVAS_OutputAdapter();

        xmlResource.getDocumentElement().normalize();
        Node node = xmlResource.getElementsByTagName("create_target_response").item(0);
        Element element = (Element) node;

        tr_openVAS_outputAdapter.setResponseType(OpenVASResponseType.CREATION);
        tr_openVAS_outputAdapter.setTargetId(element.getAttribute("id"));
        return tr_openVAS_outputAdapter;
    }

    @Override
    public TaskResponse_OpenVAS_OutputAdapter adaptToTaskResponseOpenVAS(Document xmlResource) {
        TaskResponse_OpenVAS_OutputAdapter kr_openVAS_outputAdapter = new TaskResponse_OpenVAS_OutputAdapter();

        xmlResource.getDocumentElement().normalize();
        String rootElementName = xmlResource.getDocumentElement().getTagName();
        Element rootElement;
        switch (rootElementName) {
            case "create_task_response":
                rootElement = (Element) xmlResource.getElementsByTagName("create_task_response").item(0);

                kr_openVAS_outputAdapter.setResponseType(OpenVASResponseType.CREATION);
                kr_openVAS_outputAdapter.setTaskId(rootElement.getAttribute("id"));
                break;

            case "get_tasks_response":
                rootElement = (Element) xmlResource.getElementsByTagName("get_tasks_response").item(0);
                Element task = (Element) rootElement.getElementsByTagName("task").item(0);
                Node progress = task.getElementsByTagName("progress").item(0);
                Element status = (Element) task.getElementsByTagName("status").item(0);

                kr_openVAS_outputAdapter.setResponseType(OpenVASResponseType.GET);
                kr_openVAS_outputAdapter.setTaskId(task.getAttribute("id"));
                kr_openVAS_outputAdapter.setRunningStatus(Integer.parseInt(progress.getFirstChild().getTextContent()));
                kr_openVAS_outputAdapter.setReportStatus(OpenVASReportStatus.valueOf(status.getTextContent().toUpperCase()));
                break;
        }
        return kr_openVAS_outputAdapter;
    }

    @Override
    public ReportResponse_OpenVAS_OutputAdapter adaptToReportResponseOpenVAS(Document xmlResource) {
        ReportResponse_OpenVAS_OutputAdapter rr_openVAS_outputAdapter = new ReportResponse_OpenVAS_OutputAdapter();

        xmlResource.getDocumentElement().normalize();
        String rootElementName = xmlResource.getDocumentElement().getTagName();
        Element rootElement;
        switch (rootElementName) {
            case "start_task_response":
                rootElement = (Element) xmlResource.getElementsByTagName("start_task_response").item(0);
                Element report = (Element) rootElement.getElementsByTagName("report_id").item(0);

                rr_openVAS_outputAdapter.setReportId(report.getTextContent());
                break;

            case "get_reports_response":
                rootElement = (Element) xmlResource.getElementsByTagName("get_reports_response").item(0);
                NodeList resultsElement = ((Element) ((Element) ((Element) rootElement
                        .getElementsByTagName("report").item(0))
                        .getElementsByTagName("report").item(0))
                        .getElementsByTagName("results").item(0))
                        .getElementsByTagName("result");

                TaskResult taskResult = new TaskResult(new ArrayList<>());
                for (int i = 0; i < resultsElement.getLength(); i++) {
                    Vulnerability vulnerability = new Vulnerability();
                    Element resultElement = (Element) resultsElement.item(i);
                    vulnerability.setName(resultElement.getElementsByTagName("name").item(0).getTextContent());
                    vulnerability.setPort(resultElement.getElementsByTagName("port").item(0).getTextContent());
                    vulnerability.setThreatLevel(OpenVASVulnerabilityRank.valueOf(
                            resultElement.getElementsByTagName("threat").item(0).getTextContent().toUpperCase()));

                    String[] tags = ((Element) resultElement.getElementsByTagName("nvt").item(0))
                            .getElementsByTagName("tags").item(0).getTextContent()
                            .split("\\|");
                    Pattern tagsPattern = Pattern.compile("(.*)=(.*)");
                    Map<String, String> tagMap = new HashMap<>();
                    for (String s: tags) {
                        s = Converter.removeEndLineCharacters(s);
                        Matcher matcher = tagsPattern.matcher(s);
                        if (matcher.matches()){
                            tagMap.put(matcher.group(1), matcher.group(2));
                        }
                    }
                    vulnerability.setDescription(tagMap.get("summary"));
                    vulnerability.setInsight(tagMap.get("insight"));
                    vulnerability.setImpact(tagMap.get("impact"));
                    vulnerability.setSolution(tagMap.get("solution"));
                    taskResult.addToVulnerabilityList(vulnerability);
                }
                rr_openVAS_outputAdapter.setTaskResult(taskResult);
                break;
        }
        rr_openVAS_outputAdapter.calculateThreatTypesNumber();
        return rr_openVAS_outputAdapter;
    }

    @Override
    public Metasploit_OutputAdapter adaptToMetasploit(List<String> outputLines) throws CannotAdaptCommandOutputException {
        Metasploit_OutputAdapter metasploit_outputAdapter = new Metasploit_OutputAdapter();
        metasploit_outputAdapter.setExploitList(new ArrayList<>());

        Pattern exploitRowPattern = Pattern.compile("\\s*(exploit/[\\w/]+)\\s+(\\d{4}-\\d{2}-\\d{2})?\\s+(\\w+)\\s+(.*)");

        for (String line: outputLines) {
            if (exploitRowPattern.matcher(line).matches()) {
                Exploit exploit = new Exploit();
                Matcher matcher = exploitRowPattern.matcher(line);
                matcher.matches();
                exploit.setName(matcher.group(1));
                if (matcher.group(2) != null) exploit.setDisclosureDate(Date.valueOf(matcher.group(2)));
                exploit.setRank(ExploitRank.valueOf(matcher.group(3).toUpperCase()));
                exploit.setDescription(matcher.group(4));

                metasploit_outputAdapter.addToExploitList(exploit);
            }
        }

        return metasploit_outputAdapter;
    }

    @Override
    public OutputAdapter adapt(List<String> outputLines, String command) throws CannotAdaptCommandOutputException {
        OutputAdapter outputAdapter;
        switch (command) {
            case "fping":
                outputAdapter = adaptToFping(outputLines);
                break;
            case "ifconfig":
                outputAdapter = adaptToIfconfig(outputLines);
                break;
            case "nmap":
                outputAdapter = adaptToNMAP(outputLines);
                break;
            case "omp":
                outputAdapter = adaptToOpenVAS(outputLines);
                break;
            case "msfconsole":
                outputAdapter = adaptToMetasploit(outputLines);
                break;
            default:
                outputAdapter = new Generic_OutputAdapter(outputLines);
        }
        return outputAdapter;
    }
}
