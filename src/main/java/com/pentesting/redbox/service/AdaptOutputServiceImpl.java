package com.pentesting.redbox.service;

import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonParser;
import com.pentesting.redbox.adapters.*;
import com.pentesting.redbox.beans.Exploit;
import com.pentesting.redbox.beans.HostScan;
import com.pentesting.redbox.beans.NetInterface;
import com.pentesting.redbox.beans.Port;
import com.pentesting.redbox.beans.enums.*;
import com.pentesting.redbox.utils.ListsManager;
import com.pentesting.redbox.utils.exceptions.CannotAdaptCommandOutputException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.IOException;
import java.sql.Date;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@SuppressWarnings("ResultOfMethodCallIgnored")
@Service
public class AdaptOutputServiceImpl implements AdaptOutputService {

    private static final Logger log = LoggerFactory.getLogger(AdaptOutputServiceImpl.class);

    @Override
    public SystemInfo_OutputAdapter adaptToLshw(List<String> outputLines) throws CannotAdaptCommandOutputException, IOException {
        SystemInfo_OutputAdapter systemInfo_outputAdapter = new SystemInfo_OutputAdapter();

        JsonFactory jsonFactory = new JsonFactory();
        JsonParser jsonParser = jsonFactory.createParser(ListsManager.fromListToString(outputLines, '\n'));
        return null;

    }

    // insert support for net scan
    @Override
    public Fping_OutputAdapter adaptToFping(List<String> outputLines) throws CannotAdaptCommandOutputException {
        Fping_OutputAdapter fping_outputAdapter = new Fping_OutputAdapter();
        Pattern pattern = Pattern.compile("(.*)(( is ((alive)|(unreachable)))|(: Name or service not known))");
        Matcher matcher;
        for (String line: outputLines) {
            matcher = pattern.matcher(line);
            while (true) {
                try {
                    fping_outputAdapter.setHost(matcher.group(1));
                    String group5 = matcher.group(5);
                    String group6 = matcher.group(6);
                    String group7 = matcher.group(7);
                    if (group5 != null) {
                        fping_outputAdapter.setAlive(true);
                        fping_outputAdapter.setExists(true);
                    } else if (group6 != null) {
                        fping_outputAdapter.setAlive(false);
                        fping_outputAdapter.setExists(true);
                    } else if (group7 != null) {
                        fping_outputAdapter.setAlive(false);
                        fping_outputAdapter.setExists(false);
                    }
                    break;
                } catch (IllegalStateException e) {
                    if (!matcher.matches()) throw new CannotAdaptCommandOutputException(e.getMessage(), null);
                }

            }
        }
        return fping_outputAdapter;
    }

    @Override
    public Ifconfig_OutputAdapter adaptToIfconfig(List<String> outputLines) throws CannotAdaptCommandOutputException {
        Ifconfig_OutputAdapter ifconfig_outputAdapter = new Ifconfig_OutputAdapter();
        ifconfig_outputAdapter.setInterfaceList(new ArrayList<>());

        Pattern startInterfacePattern = Pattern.compile("(\\w*)\\s+Link encap:((Ethernet\\s+HWaddr?\\s+([\\dabcdef:]+))|(Local\\s+Loopback))\\s*");
        Pattern netAddressesPattern = Pattern.compile("\\s+inet addr:([\\d.]{7,15})?\\s+(Bcast:([\\d.]{7,15}))?\\s+Mask:([\\d.]{7,15})\\s?");
        Pattern ipv6AddressPattern = Pattern.compile("\\s+inet6 addr:\\s?([\\dabcdef:/]+)\\s+Scope:\\s?([\\w]+)");

        Matcher matcher;
        NetInterface netInterface = null;
        boolean interfacePending = false;
        for (String line: outputLines) {
            if (startInterfacePattern.matcher(line).matches() && !interfacePending)  {
                netInterface = new NetInterface();
                interfacePending = true;
            }
            if (startInterfacePattern.matcher(line).matches() && interfacePending) {
                matcher = startInterfacePattern.matcher(line);
                log.info(String.valueOf(matcher.groupCount()));
                matcher.matches();
                netInterface.setName(matcher.group(1));
                netInterface.setMacAddress(matcher.group(4));
            } else if (netAddressesPattern.matcher(line).matches() && interfacePending) {
                matcher = netAddressesPattern.matcher(line);
                log.info(String.valueOf(matcher.groupCount()));
                matcher.matches();
                netInterface.setIpv4Address(matcher.group(1));
                netInterface.setBroadcastAddress(matcher.group(3));
                netInterface.setSubnetMask(matcher.group(4));
            } else if (ipv6AddressPattern.matcher(line).matches() && interfacePending) {
                matcher = ipv6AddressPattern.matcher(line);
                log.info(String.valueOf(matcher.groupCount()));
                matcher.matches();
                netInterface.setIpv6Address(matcher.group(1));
                interfacePending = false;
                ifconfig_outputAdapter.insertIntoInterfaceList(netInterface);
            }
        }
        return ifconfig_outputAdapter;
    }

//    @Override
//    public Macchanger_OutputAdapter adaptToMacchanger(List<String> outputLines) throws CannotAdaptCommandOutputException {
//        Macchanger_OutputAdapter macchanger_outputAdapter = new Macchanger_OutputAdapter();
//
//        String currentMacPattern = "Current MAC:[\\s]+.{17}[\\s]+\\(.*\\)";
//        String permanentMacPattern = "Permanent MAC:[\\s]+.{17}[\\s]+\\(.*\\)";
//        String newMacPattern = "New MAC:[\\s]+.{17}[\\s]+\\(.*\\)";
//
//        for (String line: outputLines) {
//            if (line.matches(currentMacPattern)) {
//                macchanger_outputAdapter.setCurrentMac(StringGetter.getMACAddress(line));
//            } else if (line.matches(permanentMacPattern)){
//                macchanger_outputAdapter.setPermanentMac(StringGetter.getMACAddress(line));
//            } else if (line.matches(newMacPattern)){
//                macchanger_outputAdapter.setNewMac(StringGetter.getMACAddress(line));
//            } else {
//                throw new CannotAdaptCommandOutputException();
//            }
//        }
//        return macchanger_outputAdapter;
//    }

    @Override
    public NMAP_OutputAdapter adaptToNMAP(List<String> outputLines) throws CannotAdaptCommandOutputException {
        NMAP_OutputAdapter nmap_outputAdapter = new NMAP_OutputAdapter();
        nmap_outputAdapter.setHostScanList(new ArrayList<>());

        Pattern initPattern = Pattern.compile("Starting Nmap [\\d.]+ \\( https://nmap\\.org \\) at .*");
        Pattern hostStartScanPattern = Pattern.compile("Nmap scan report for (.*)");
        Pattern hostStatusPattern = Pattern.compile("(Note: )?Host ((seems down)|(is up)).*");
        Pattern portStatusRowPattern = Pattern.compile("(\\d+)/(tcp|udp)\\s+([\\w\\|]+)\\s+(.+)");
        Pattern endingPattern = Pattern.compile("Nmap done: (\\d)+ IP address(es)? \\([\\d]+ host[s]? up\\) scanned in ([\\d.]+) seconds");

        Matcher matcher;
        HostScan hostScan = null;
        for (String line: outputLines) {

            if(outputLines.indexOf(line) == 1 && !initPattern.matcher(line).matches())
                throw new CannotAdaptCommandOutputException(null);

            if (hostStartScanPattern.matcher(line).matches()) {
                matcher = hostStartScanPattern.matcher(line);
                matcher.matches();
                if (hostScan != null) nmap_outputAdapter.insertIntoHostScanList(hostScan);
                hostScan = new HostScan();
                hostScan.setPorts(new ArrayList<>());
                hostScan.setHostname(matcher.group(1));
            } else if (hostStatusPattern.matcher(line).matches()) {
                matcher = hostStatusPattern.matcher(line);
                matcher.matches();
                if (matcher.group(3) != null) Objects.requireNonNull(hostScan).setUp(false);
                else Objects.requireNonNull(hostScan).setUp(true);
            } else if (portStatusRowPattern.matcher(line).matches()) {
                matcher = portStatusRowPattern.matcher(line);
                matcher.matches();
                Port port = new Port();
                port.setPortNumber(Integer.parseInt(matcher.group(1)));
                port.setProtocol(PortTransportProtocol.valueOf(matcher.group(2).toUpperCase()));
                port.setPortStatus(PortStatus.valueOf(matcher.group(3).toUpperCase().replace("|", "_")));
                port.setService(matcher.group(4));
                Objects.requireNonNull(hostScan).insertIntoPorts(port);
            } else if (endingPattern.matcher(line).matches()) {
                matcher = endingPattern.matcher(line);
                matcher.matches();
                if (hostScan != null) nmap_outputAdapter.insertIntoHostScanList(hostScan);
                nmap_outputAdapter.setScanningTime(Float.valueOf(matcher.group(3)));
            }
        }
        return nmap_outputAdapter;
    }

//    @Override
//    public OpenVAS_OutputAdapter adaptToOpenVAS(List<String> outputLines) throws CannotAdaptCommandOutputException {
//        OpenVAS_OutputAdapter openVAS_outputAdapter = new OpenVAS_OutputAdapter();
//
//        Pattern firstLineReportPattern = Pattern.compile("I Summary");
//        Pattern issueLineReportPattern = Pattern.compile("Issue");
//        Pattern nvtLineReportPattern = Pattern.compile("NVT:\\s+(.*)");
//        Pattern threatLineReportPattern = Pattern.compile("Threat:\\s+(.*)");
//        Pattern portLineReportPattern = Pattern.compile("Port:\\s+(.*)");
//        Pattern descriptionLineReportPattern = Pattern.compile("Summary:");
//
//        Pattern reportTaskPattern = Pattern.compile("([\\dabcdef\\-]+)");
//        Pattern taskResponsePattern = Pattern.compile("<create_task_response id=\"([\\dabcdef\\-]+)\" status_text=\"(.*)\" status=\"(\\d+)\"></create_task_response>");
//        Pattern targetResponsePattern = Pattern.compile("<create_target_response id=\"([\\dabcdef\\-]+)\" status_text=\"(.*)\" status=\"(\\d+)\"></create_target_response>");
//
//        boolean report = false;
//        boolean inIssue = false;
//        boolean summaryIssue = false;
//        List<Vulnerability> vulnerabilityList = null;
//        Vulnerability vulnerability = null;
//        Matcher matcher;
//        for (String line: outputLines) {
//            if (report) {
//                if (issueLineReportPattern.matcher(line).matches()) {
//                    inIssue = true;
//                    vulnerability = new Vulnerability();
//                }
//                if (inIssue) {
//                    if (nvtLineReportPattern.matcher(line).matches()) {
//                        matcher = nvtLineReportPattern.matcher(line);
//                        matcher.matches();
//                        vulnerability.setName(matcher.group(1));
//                    } else if (threatLineReportPattern.matcher(line).matches()) {
//                        matcher = threatLineReportPattern.matcher(line);
//                        matcher.matches();
//                        vulnerability.setThreatLevel(matcher.group(1));
//                    } else if (portLineReportPattern.matcher(line).matches()) {
//                        matcher = portLineReportPattern.matcher(line);
//                        matcher.matches();
//                        vulnerability.setPort(matcher.group(1));
//                    } else if (descriptionLineReportPattern.matcher(line).matches()) {
//                        summaryIssue = true;
//                    } else if (summaryIssue) {
//                        vulnerability.setDescription(line);
//                        summaryIssue = false;
//                        vulnerabilityList.add(vulnerability);
//                        inIssue = false;
//                    }
//                }
//            } else if (reportTaskPattern.matcher(line).matches()) {
//                matcher = reportTaskPattern.matcher(line);
//                matcher.matches();
//                openVAS_outputAdapter.setReportId(matcher.group(1));
//            } else if (taskResponsePattern.matcher(line).matches()) {
//                matcher = taskResponsePattern.matcher(line);
//                matcher.matches();
//                if (matcher.group(3).matches("2[\\d]{2}")) {
//                    openVAS_outputAdapter.setTaskId(matcher.group(1));
//                }
//            } else if (targetResponsePattern.matcher(line).matches()) {
//                matcher = targetResponsePattern.matcher(line);
//                matcher.matches();
//                if (matcher.group(3).matches("2[\\d]{2}")) {
//                    openVAS_outputAdapter.setTargetId(matcher.group(1));
//                }
//            } else if (firstLineReportPattern.matcher(line).matches()) {
//                vulnerabilityList = new ArrayList<>();
//                report = true;
//            }
//        }
//
//        if (report) {
//            openVAS_outputAdapter.setTaskResult(new TaskResult(vulnerabilityList));
//            openVAS_outputAdapter.calculateThreatTypesNumber();
//        }
//        return openVAS_outputAdapter;
//    }

    @Override
    public OpenVAS_OutputAdapter adaptToOpenVAS(List<String> outputLines) {
        String xml;
        if (outputLines.size() != 1) xml = ListsManager.fromListToString(outputLines, '\n');
        else xml = outputLines.get(0);

        try {
            DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newDefaultInstance();
            DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
            Document document = documentBuilder.parse(xml);
            String rootElement = document.getDocumentElement().getNodeName();
            switch (rootElement) {
                case "create_target_response":
                    return adaptToTargetResponseOpenVAS(document);
                case "create_task_response":
                    return adaptToTaskResponseOpenVAS(document);
                case "get_reports_response":
                    return adaptToReportResponseOpenVAS(document);
                case "start_task_response":
                    return adaptToReportResponseOpenVAS(document);
                default:
                    return null;
            }
        } catch (ParserConfigurationException | SAXException | IOException e) {
            e.printStackTrace();
            return null;
        }
    }

    @Override
    public TargetResponse_OpenVAS_OutputAdapter adaptToTargetResponseOpenVAS(Document xmlResource) {
        TargetResponse_OpenVAS_OutputAdapter tr_openVAS_outputAdapter = new TargetResponse_OpenVAS_OutputAdapter();

        xmlResource.getDocumentElement().normalize();
        Node node = xmlResource.getElementsByTagName("create_target_response").item(0);
        Element element = (Element) node;

        tr_openVAS_outputAdapter.setResponseType(OpenVASResponseType.CREATION);
        tr_openVAS_outputAdapter.setTargetId(element.getAttribute("id"));
        return tr_openVAS_outputAdapter;
    }

    @Override
    public TaskResponse_OpenVAS_OutputAdapter adaptToTaskResponseOpenVAS(Document xmlResource) {
        TaskResponse_OpenVAS_OutputAdapter kr_openVAS_outputAdapter = new TaskResponse_OpenVAS_OutputAdapter();

        xmlResource.getDocumentElement().normalize();
        String rootElementName = xmlResource.getDocumentElement().getTagName();
        Element rootElement;
        switch (rootElementName) {
            case "create_task_response":
                rootElement = (Element) xmlResource.getElementsByTagName("create_task_response").item(0);

                kr_openVAS_outputAdapter.setResponseType(OpenVASResponseType.CREATION);
                kr_openVAS_outputAdapter.setTaskId(rootElement.getAttribute("id"));
                break;

            case "get_tasks_response":
                rootElement = (Element) xmlResource.getElementsByTagName("get_tasks_response").item(0);
                Element task = (Element) rootElement.getElementsByTagName("task").item(0);
                Element progress = (Element) task.getElementsByTagName("progress").item(0);
                Element status = (Element) task.getElementsByTagName("status").item(0);

                kr_openVAS_outputAdapter.setResponseType(OpenVASResponseType.GET);
                kr_openVAS_outputAdapter.setTaskId(task.getAttribute("id"));
                kr_openVAS_outputAdapter.setRunningStatus(Integer.parseInt(progress.getTextContent()));
                kr_openVAS_outputAdapter.setReportStatus(OpenVASReportStatus.valueOf(status.getTextContent().toUpperCase()));
                break;
        }
        return kr_openVAS_outputAdapter;
    }

    @Override
    public ReportResponse_OpenVAS_OutputAdapter adaptToReportResponseOpenVAS(Document xmlResource) {
        ReportResponse_OpenVAS_OutputAdapter rr_openVAS_outputAdapter = new ReportResponse_OpenVAS_OutputAdapter();

        xmlResource.getDocumentElement().normalize();
        String rootElementName = xmlResource.getDocumentElement().getTagName();
        Element rootElement;
        switch (rootElementName) {
            case "start_task_response":
                rootElement = (Element) xmlResource.getElementsByTagName("start_task_response").item(0);
                Element report = (Element) rootElement.getElementsByTagName("report_id");

                rr_openVAS_outputAdapter.setReportId(report.getTextContent());
                break;

            case "get_reports_response":
                rootElement = (Element) xmlResource.getElementsByTagName("get_reports_response").item(0);
                //...
                break;
        }
        return rr_openVAS_outputAdapter;
    }

    @Override
    public Metasploit_OutputAdapter adaptToMetasploit(List<String> outputLines) throws CannotAdaptCommandOutputException {
        Metasploit_OutputAdapter metasploit_outputAdapter = new Metasploit_OutputAdapter();
        metasploit_outputAdapter.setExploitList(new ArrayList<>());

        Pattern exploitRowPattern = Pattern.compile("\\s*(exploit/[\\w/]+)\\s+(\\d{4}-\\d{2}-\\d{2})?\\s+(\\w+)\\s+(.*)");

        for (String line: outputLines) {
            if (exploitRowPattern.matcher(line).matches()) {
                Exploit exploit = new Exploit();
                Matcher matcher = exploitRowPattern.matcher(line);
                matcher.matches();
                exploit.setName(matcher.group(1));
                if (matcher.group(2) != null) exploit.setDisclosureDate(Date.valueOf(matcher.group(2)));
                exploit.setRank(ExploitRank.valueOf(matcher.group(3).toUpperCase()));
                exploit.setDescription(matcher.group(4));

                metasploit_outputAdapter.addToExploitList(exploit);
            }
        }

        return metasploit_outputAdapter;
    }

    @Override
    public OutputAdapter adapt(List<String> outputLines, String command) throws CannotAdaptCommandOutputException {
        OutputAdapter outputAdapter;
        switch (command) {
            case "fping":
                outputAdapter = adaptToFping(outputLines);
                break;
            case "ifconfig":
                outputAdapter = adaptToIfconfig(outputLines);
                break;
            case "nmap":
                outputAdapter = adaptToNMAP(outputLines);
                break;
            case "omp":
                outputAdapter = adaptToOpenVAS(outputLines);
                break;
            case "msfconsole":
                outputAdapter = adaptToMetasploit(outputLines);
                break;
            default:
                outputAdapter = new Generic_OutputAdapter(outputLines);
        }
        return outputAdapter;
    }
}
